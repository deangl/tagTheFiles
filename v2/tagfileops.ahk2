#include toolFunc.ahk2

readTagFile(fileName){
    rslt := Map()
    if !FileExist(fileName) {
        return rslt
    }
    f := FileRead(fileName)
    if (f == "") {
        return rslt
    }
    raw := StrSplit(f, "`n", "`r")
    for i, v in raw {
        if (v == "") {
            continue
        }
        ; Handle Windows line endings by removing trailing carriage return
        if (SubStr(v, -1) == "`r") {
            v := SubStr(v, 1, StrLen(v) - 1)
        }
        ; Check if the line ends with >>>> and remove it
        if (SubStr(v, -4) == ">>>>") {
            v := SubStr(v, 1, StrLen(v) - 4)
        }
        ; Restore newlines in the content before splitting
        v := StrReplace(v, "@n@", "`n")
        d := StrSplit(v, "{<>}")
        if (d.Length >= 3) {
            filePath := d[1]
            tag := d[2]
            desc := d[3]
            if (filePath != "") {
                fileInfo := Map()
                fileInfo["tag"] := tag
                fileInfo["desc"] := desc
                rslt[filePath] := fileInfo
            }
        }
    }
    return rslt
}

writeTagFile(fileName, data){
    keyList := []
    for k, v in data {
        keyList.Push(k)
    }
    keyList := SortStringArr(keyList)

    raw := ""
    for i, k in keyList {
        if (StrLen(k) > 0) {
            ; Ensure we always have tag and desc fields
            tagValue := data[k].Has("tag") ? data[k]["tag"] : ""
            descValue := data[k].Has("desc") ? data[k]["desc"] : ""
            
            ; Replace newlines with @n@ for storage
            tagValue := StrReplace(tagValue, "`n", "@n@")
            descValue := StrReplace(descValue, "`n", "@n@")
            
            raw .= k . "{<>}" . tagValue . "{<>}" . descValue . ">>>>`n"
        }
    }
    FileDelete(fileName)
    FileAppend(raw, fileName)
    MsgBox("更新完成")
    return
}



